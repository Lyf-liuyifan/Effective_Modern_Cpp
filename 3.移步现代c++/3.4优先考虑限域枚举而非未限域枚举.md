# 3.4优先考虑限域枚举而非未限域枚举
  未限域枚举在同一个作用域中不能声明定义与枚举中相同名字的变量，但是限域枚举就可以，其实就是定义了一个枚举类

```
enum Color { black, white, red };   //black, white, red在
                                    //Color所在的作用域
auto white = false;                 //错误! white早已在这个作用
                                    //域中声明

```

```
enum class Color { black, white, red }; //black, white, red
                                        //限制在Color域内
auto white = false;                     //没问题，域内没有其他“white”

Color c = white;                        //错误，域中没有枚举名叫white

Color c = Color::white;                 //没问题
auto c = Color::white;                  //也没问题（也符合Item5的建议）

```

  限域枚举可以禁止隐式类型转换，比如包含枚举的比较和计算或者是函数形参类型的隐式转换等情况。比如：

```
enum class Color { black, white, red }; //Color现在是限域enum

Color c = Color::red;                   //和之前一样，只是
...                                     //多了一个域修饰符

if (c < 14.5) {                         //错误！不能比较
                                        //Color和double
    auto factors =                      //错误！不能向参数为std::size_t
      primeFactors(c);                  //的函数传递Color参数
    …
}


```
第三个好处：限域enum可以被前置声明
未限域枚举声明是不被允许的，所以编译器可以在使用之前为每一个enum选择一个底层类型。
  限域枚举类可以前置声明，意味着可以减少编译依赖，减少编译需要的时间。

1. C++98的enum即非限域enum。
2. 限域enum的枚举名仅在enum内可见。要转换为其它类型只能使用cast。
3. 非限域/限域enum都支持底层类型说明语法，限域enum底层类型默认是int。非限域enum没有默认底层类型。
4. 限域enum总是可以前置声明。非限域enum仅当指定它们的底层类型时才能前置。